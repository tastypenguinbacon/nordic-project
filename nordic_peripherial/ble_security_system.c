/* This file was generated by plugin 'Nordic Semiconductor nRF5x v.1.2.4' (BDS version 1.1.3135.0) */

#include "ble_security_system.h"
#include <string.h>
#include "nordic_common.h"
#include "ble_srv_common.h"
#include "app_util.h"
#include "app_util_bds.h"
#include "nrf_gpio.h"


#define OPCODE_LENGTH 1 /**< Length of opcode inside Security_system packet. */
#define HANDLE_LENGTH 2 /**< Length of handle inside Security_system packet. */

/* TODO Consider changing the max values if encoded data for characteristic/descriptor is fixed length */ 
#define MAX_MOTIONS_SENSOR_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted motions_sensor. */ 
#define MAX_DOOR_CONTROLLER_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Door_controller. */ 
#define MAX_DOOR_LOCK_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Door_lock. */ 

/**@brief Function for encoding motions_sensor.
 *
 * @param[in]   p_motions_sensor              motions_sensor characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t motions_sensor_encode(ble_security_system_motions_sensor_t * p_motions_sensor, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    encoded_buffer[len++] = p_motions_sensor->sensor_1;
    len += bds_uint32_encode(&p_motions_sensor->sensor_1_time, &encoded_buffer[len]); 
    encoded_buffer[len++] = p_motions_sensor->sensor_2;
    len += bds_uint32_encode(&p_motions_sensor->sensor_2_time, &encoded_buffer[len]); 
    return len;
}

/**@brief Function for decoding motions_sensor.
 *
 * @param[in]   data_len              Length of the field to be decoded.
 * @param[in]   p_data                Buffer where the encoded data is stored.
 * @param[out]  p_write_val           Decoded data.
 *
 * @return      Length of the decoded field.
 */
static uint8_t motions_sensor_decode(uint8_t data_len, uint8_t * p_data, ble_security_system_motions_sensor_t * p_write_val)
{
    uint8_t pos = 0;
    p_write_val->sensor_1 = p_data[pos++]; 
    pos += bds_uint32_decode((data_len-pos), &p_data[pos], &p_write_val->sensor_1_time); 
    p_write_val->sensor_2 = p_data[pos++]; 
    pos += bds_uint32_decode((data_len-pos), &p_data[pos], &p_write_val->sensor_2_time); 

    return pos;
} 
/**@brief Function for encoding Door_controller.
 *
 * @param[in]   p_door_controller              Door_controller characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t door_controller_encode(ble_security_system_door_controller_t * p_door_controller, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    encoded_buffer[len++] = p_door_controller->door_close;
    return len;
}

/**@brief Function for decoding Door_controller.
 *
 * @param[in]   data_len              Length of the field to be decoded.
 * @param[in]   p_data                Buffer where the encoded data is stored.
 * @param[out]  p_write_val           Decoded data.
 *
 * @return      Length of the decoded field.
 */
static uint8_t door_controller_decode(uint8_t data_len, uint8_t * p_data, ble_security_system_door_controller_t * p_write_val)
{
    uint8_t pos = 0;
    p_write_val->door_close = p_data[pos++]; 

    return pos;
} 
/**@brief Function for encoding Door_lock.
 *
 * @param[in]   p_door_lock              Door_lock characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t door_lock_encode(ble_security_system_door_lock_t * p_door_lock, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    encoded_buffer[len++] = p_door_lock->d_lock;
    return len;
}

/**@brief Function for decoding Door_lock.
 *
 * @param[in]   data_len              Length of the field to be decoded.
 * @param[in]   p_data                Buffer where the encoded data is stored.
 * @param[out]  p_write_val           Decoded data.
 *
 * @return      Length of the decoded field.
 */
static uint8_t door_lock_decode(uint8_t data_len, uint8_t * p_data, ble_security_system_door_lock_t * p_write_val)
{
    uint8_t pos = 0;
    p_write_val->d_lock = p_data[pos++]; 

    return pos;
} 

/**@brief Function for handling the Connect event.
 *
 * @param[in]   p_security_system       Security_system Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_connect(ble_security_system_t * p_security_system, ble_evt_t * p_ble_evt)
{
    p_security_system->conn_handle = p_ble_evt->evt.gap_evt.conn_handle;
}

/**@brief Function for handling the Disconnect event.
 *
 * @param[in]   p_security_system       Security_system Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_disconnect(ble_security_system_t * p_security_system, ble_evt_t * p_ble_evt)
{
    UNUSED_PARAMETER(p_ble_evt);
    p_security_system->conn_handle = BLE_CONN_HANDLE_INVALID;
}

/**@brief Function for handling the Write event.
 *
 * @param[in]   p_security_system       Security_system Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_write(ble_security_system_t * p_security_system, ble_gatts_evt_write_t * p_ble_evt)
{
    
    if(p_ble_evt->handle == p_security_system->motions_sensor_handles.value_handle)
    {
        if(p_security_system->evt_handler != NULL)
        {
            ble_security_system_evt_t evt;
						//wlasny kod /wlasny kod/wlasny kod/wlasny kod/wlasny kod/wlasny kod/wlasny kod/wlasny kod
						//p_ble_evt->data[0]=(uint8_t)nrf_gpio_pin_read(19);
						//p_ble_evt->data[1]=(uint8_t)nrf_gpio_pin_read(20);
								
            evt.evt_type = BLE_SECURITY_SYSTEM_MOTIONS_SENSOR_EVT_WRITE;
            motions_sensor_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.motions_sensor);
					
            p_security_system->evt_handler(p_security_system, &evt);
        }
    }
    if(p_ble_evt->handle == p_security_system->door_controller_handles.value_handle)
    {
        if(p_security_system->evt_handler != NULL)
        {
            ble_security_system_evt_t evt;
            evt.evt_type = BLE_SECURITY_SYSTEM_DOOR_CONTROLLER_EVT_WRITE;
            door_controller_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.door_controller);
							//wlasny kod /wlasny kod/wlasny kod/wlasny kod/wlasny kod/wlasny kod/wlasny kod/wlasny kod				
            p_security_system->evt_handler(p_security_system, &evt);
        }
    }
    if(p_ble_evt->handle == p_security_system->door_lock_handles.value_handle)
    {
        if(p_security_system->evt_handler != NULL)
        {
            ble_security_system_evt_t evt;
            evt.evt_type = BLE_SECURITY_SYSTEM_DOOR_LOCK_EVT_WRITE;
            door_lock_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.door_lock);
            p_security_system->evt_handler(p_security_system, &evt);
        }
    }
}

/**@brief Authorize WRITE request event handler.
 *
 * @details Handles WRITE events from the BLE stack.
 *
 * @param[in]   p_sc_ctrlpt  SC Ctrlpt structure.
 * @param[in]   p_gatts_evt  GATTS Event received from the BLE stack.
 *
 */
static void on_rw_authorize_request(ble_security_system_t * p_security_system, ble_gatts_evt_t * p_gatts_evt)
{
    ble_gatts_evt_rw_authorize_request_t * p_auth_req = &p_gatts_evt->params.authorize_request;
    if (p_auth_req->type == BLE_GATTS_AUTHORIZE_TYPE_WRITE)
    {
        if (   (p_gatts_evt->params.authorize_request.request.write.op
                != BLE_GATTS_OP_PREP_WRITE_REQ)
            && (p_gatts_evt->params.authorize_request.request.write.op
                != BLE_GATTS_OP_EXEC_WRITE_REQ_NOW)
            && (p_gatts_evt->params.authorize_request.request.write.op
                != BLE_GATTS_OP_EXEC_WRITE_REQ_CANCEL)
           )
        {
        
            if (p_auth_req->request.write.handle == p_security_system->motions_sensor_handles.value_handle)
            {
                on_write(p_security_system, &p_auth_req->request.write);
            }
            if (p_auth_req->request.write.handle == p_security_system->door_controller_handles.value_handle)
            {
                on_write(p_security_system, &p_auth_req->request.write);
            }
            if (p_auth_req->request.write.handle == p_security_system->door_lock_handles.value_handle)
            {
                on_write(p_security_system, &p_auth_req->request.write);
            }
        }
    }
}

/**@brief Function for handling BLE events.
 *
 * @param[in]   p_security_system       Security_system Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
void ble_security_system_on_ble_evt(ble_security_system_t * p_security_system, ble_evt_t * p_ble_evt)
{
    switch (p_ble_evt->header.evt_id)
    {
        case BLE_GAP_EVT_CONNECTED:
            on_connect(p_security_system, p_ble_evt);
            break;
        case BLE_GAP_EVT_DISCONNECTED:
            on_disconnect(p_security_system, p_ble_evt);
            break;
        case BLE_GATTS_EVT_WRITE:
            on_write(p_security_system, &p_ble_evt->evt.gatts_evt.params.write);
            break;
         case BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST:
            on_rw_authorize_request(p_security_system, &p_ble_evt->evt.gatts_evt);
            break;
        default:
            //No implementation needed.
            break;
    }
}

/**@brief Function for initializing the Security_system. */
uint32_t ble_security_system_init(ble_security_system_t * p_security_system, const ble_security_system_init_t * p_security_system_init)
{
    uint32_t err_code;
    ble_uuid_t ble_uuid;

    // Initialize service structure
    p_security_system->evt_handler = p_security_system_init->evt_handler;
    p_security_system->conn_handle = BLE_CONN_HANDLE_INVALID;
    
    // Add a custom base UUID.
    ble_uuid128_t bds_base_uuid = {{0x70, 0x6F, 0x8F, 0x08, 0xE5, 0x4E, 0x0C, 0x91, 0xE9, 0x45, 0xBB, 0xF8, 0x00, 0x00, 0x0B, 0x72}};
    uint8_t       uuid_type;
    err_code = sd_ble_uuid_vs_add(&bds_base_uuid, &uuid_type);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    }
    ble_uuid.type = uuid_type;
    ble_uuid.uuid = 0xA4A5;
        
    // Add service
    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_security_system->service_handle);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add motions_sensor characteristic
    ble_security_system_motions_sensor_t motions_sensor_initial_value = p_security_system_init->ble_security_system_motions_sensor_initial_value; 

    uint8_t motions_sensor_encoded_value[1];
    ble_add_char_params_t add_motions_sensor_params;
    memset(&add_motions_sensor_params, 0, sizeof(add_motions_sensor_params));
    
    add_motions_sensor_params.uuid                = 0xFA44;
    add_motions_sensor_params.uuid_type           = ble_uuid.type; 
    add_motions_sensor_params.max_len             = 1;
    add_motions_sensor_params.init_len            = motions_sensor_encode(&motions_sensor_initial_value, motions_sensor_encoded_value);
    add_motions_sensor_params.p_init_value        = motions_sensor_encoded_value; 
    add_motions_sensor_params.char_props.write    = 1; 
    add_motions_sensor_params.write_access        = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_motions_sensor_params.is_var_len          = 1; 

    err_code = characteristic_add(p_security_system->service_handle, &add_motions_sensor_params, &(p_security_system->motions_sensor_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add Door_controller characteristic
    ble_security_system_door_controller_t door_controller_initial_value = p_security_system_init->ble_security_system_door_controller_initial_value; 

    uint8_t door_controller_encoded_value[1];
    ble_add_char_params_t add_door_controller_params;
    memset(&add_door_controller_params, 0, sizeof(add_door_controller_params));
    
    add_door_controller_params.uuid                = 0x622E;
    add_door_controller_params.uuid_type           = ble_uuid.type; 
    add_door_controller_params.max_len             = 1;
    add_door_controller_params.init_len            = door_controller_encode(&door_controller_initial_value, door_controller_encoded_value);
    add_door_controller_params.p_init_value        = door_controller_encoded_value; 
    add_door_controller_params.char_props.write    = 1; 
    add_door_controller_params.write_access        = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_door_controller_params.is_var_len          = 1; 

    err_code = characteristic_add(p_security_system->service_handle, &add_door_controller_params, &(p_security_system->door_controller_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add Door_lock characteristic
    ble_security_system_door_lock_t door_lock_initial_value = p_security_system_init->ble_security_system_door_lock_initial_value; 

    uint8_t door_lock_encoded_value[1];
    ble_add_char_params_t add_door_lock_params;
    memset(&add_door_lock_params, 0, sizeof(add_door_lock_params));
    
    add_door_lock_params.uuid                = 0x5150;
    add_door_lock_params.uuid_type           = ble_uuid.type; 
    add_door_lock_params.max_len             = 1;
    add_door_lock_params.init_len            = door_lock_encode(&door_lock_initial_value, door_lock_encoded_value);
    add_door_lock_params.p_init_value        = door_lock_encoded_value; 
    add_door_lock_params.char_props.read     = 1; 
    add_door_lock_params.read_access         = SEC_OPEN; 
    add_door_lock_params.char_props.write    = 1; 
    add_door_lock_params.write_access        = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_door_lock_params.is_var_len          = 1; 

    err_code = characteristic_add(p_security_system->service_handle, &add_door_lock_params, &(p_security_system->door_lock_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    return NRF_SUCCESS;
}

/**@brief Function for setting the Door_lock. */
uint32_t ble_security_system_door_lock_set(ble_security_system_t * p_security_system, ble_security_system_door_lock_t * p_door_lock)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[1];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = door_lock_encode(p_door_lock, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_security_system->conn_handle, p_security_system->door_lock_handles.value_handle, &gatts_value);
}

uint32_t ble_security_system_door_controller_set(ble_security_system_t * p_security_system, ble_security_system_door_controller_t * p_door_controller)
{
		ble_gatts_value_t gatts_value;
    uint8_t encoded_value[1];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = door_controller_encode(p_door_controller, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    //sd_ble_gatts_value_set(p_security_system->conn_handle, p_security_system->door_controller_handles.value_handle, &gatts_value);
	
		
		//???????????????????????????????????????????
            ble_gatts_hvx_params_t hvx_params;

            memset(&hvx_params, 0, sizeof(hvx_params));

            hvx_params.handle = p_security_system->door_controller_handles.value_handle;
            hvx_params.type   = BLE_GATT_HVX_NOTIFICATION;
            hvx_params.offset = gatts_value.offset;
            hvx_params.p_len  = &gatts_value.len;
            hvx_params.p_data = gatts_value.p_value;

            sd_ble_gatts_hvx(p_security_system->conn_handle, &hvx_params);
     //??????????????????????????????????????????? 
	
		return 1;
	
	
}
uint32_t ble_security_system_motions_sensor_set(ble_security_system_t * p_security_system, ble_security_system_motions_sensor_t * p_sensors)
{
	ble_gatts_value_t gatts_value;
    uint8_t encoded_value[1];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = motions_sensor_encode(p_sensors, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    //sd_ble_gatts_value_set(p_security_system->conn_handle, p_security_system->motions_sensor_handles.value_handle, &gatts_value);
	
	
	
		//???????????????????????????????????????????
            ble_gatts_hvx_params_t hvx_params;

            memset(&hvx_params, 0, sizeof(hvx_params));

            hvx_params.handle = p_security_system->motions_sensor_handles.value_handle;
            hvx_params.type   = BLE_GATT_HVX_NOTIFICATION;
            hvx_params.offset = gatts_value.offset;
            hvx_params.p_len  = &gatts_value.len;
            hvx_params.p_data = gatts_value.p_value;

            sd_ble_gatts_hvx(p_security_system->conn_handle, &hvx_params);
     //??????????????????????????????????????????? 
	
		return 1;
}

